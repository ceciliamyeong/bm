<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Market Structure | Blockmedia Data</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
      background: #fafafa;
    }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .top { display:flex; align-items: baseline; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .title { font-size: 20px; font-weight: 800; }
    .sub { color:#666; font-size: 12px; }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; margin-top: 12px; }
    .card { border: 1px solid #eee; border-radius: 12px; padding: 12px; background: #fff; }
    .span-12 { grid-column: span 12; }
    .span-6  { grid-column: span 6; }
    @media (max-width: 900px){ .span-6 { grid-column: span 12; } }

    .muted { color:#777; font-size: 12px; margin-top: 6px; line-height: 1.35; }

    .kpi { display:flex; gap: 10px; align-items: baseline; flex-wrap: wrap; }
    .kpi .v { font-size: 22px; font-weight: 900; }
    .kpi .l { font-size: 12px; color:#666; }

    /* ✅ 차트 무한 높이 증가 방지 */
    .chartbox { position: relative; height: 340px; }
    .chartbox canvas { width: 100% !important; height: 100% !important; display: block; }

    .controls {
      display:flex; gap: 8px; flex-wrap: wrap; align-items: center;
      margin: 6px 0 10px;
    }
    .btn {
      border: 1px solid #e5e5e5;
      background: #fff;
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
    }
    .btn.active { border-color: #bbb; font-weight: 700; }
    .pill {
      font-size: 12px; color:#666;
      border: 1px solid #eee; padding: 6px 10px; border-radius: 999px;
      background:#fafafa;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div class="title">Market Structure</div>
      <div class="sub" id="asof">Loading…</div>
    </div>

    <div class="grid">

      <!-- KPI: XRP -->
      <div class="card span-12">
        <div class="kpi">
          <div class="v" id="kpi-xrp">—</div>
          <div class="l">K-XRP Spot Share (24H)</div>

          <div class="v" id="kpi-usdkrw" style="margin-left:16px;">—</div>
          <div class="l">USDKRW</div>

          <div class="v" id="kpi-xrp-errors" style="margin-left:16px;">—</div>
          <div class="l">Errors</div>
        </div>
        <div class="muted" id="note-xrp">
          * Korea = Upbit+Bithumb+Coinone XRP/KRW spot traded value(24h) → USD 환산 /
          Global = CMC XRP volume_24h(USD)
        </div>
      </div>

      <!-- XRP Chart -->
      <div class="card span-12">
        <div style="font-weight:800; margin-bottom:6px;">K-XRP Spot Share (24H)</div>
        <div class="chartbox"><canvas id="chart-xrp"></canvas></div>
        <div class="muted" id="note-xrp-2"></div>
      </div>

      <!-- JPBitcoin: Turnover + Price -->
      <div class="card span-12">
        <div style="font-weight:800; margin-bottom:6px;">
          Global Monthly Turnover (JPY conversion, 단위: 억엔) + BTC Price
        </div>

        <div class="controls">
          <span class="pill">View</span>
          <button class="btn active" id="btn-view-month">월별</button>
          <button class="btn" id="btn-view-year">연별</button>

          <span class="pill" style="margin-left:10px;">Range</span>
          <button class="btn" id="btn-range-5y">5Y</button>
          <button class="btn" id="btn-range-10y">10Y</button>
          <button class="btn active" id="btn-range-all">ALL</button>

          <span class="pill" style="margin-left:10px;" id="fx-pill">FX(USDJPY): —</span>
          <span class="pill" id="usd-approx-pill">USD 환산(근사): —</span>
        </div>

        <div class="chartbox"><canvas id="chart-jpbtc"></canvas></div>
        <div class="muted" id="note-jpbtc">
          * 막대=월간 거래액(월평균가 기준 엔환산, 억엔), 라인=월 평균 BTC가격(JPY/BTC). (JPBitcoin 방식)
        </div>
      </div>

      <!-- Korea Share from JPBitcoin (KRW / Total) -->
      <div class="card span-6">
        <div style="font-weight:800; margin-bottom:6px;">Korea Share (JPBitcoin, KRW / Total)</div>
        <div class="chartbox"><canvas id="chart-krw-share"></canvas></div>
        <div class="muted" id="note-krw-share">
          * JPBitcoin 표본 내 통화 합 대비 KRW 비중. (파생 포함/제외 이슈와 별개: 여기서는 JPBitcoin 기준)
        </div>
      </div>

      <!-- BTC monthly share / liquidity placeholders (keep) -->
      <div class="card span-6">
        <div style="font-weight:800; margin-bottom:6px;">(Optional) Additional Monthly Files</div>
        <div class="muted">
          * out/global/k_btc_share_monthly.json, out/global/global_btc_liquidity_monthly.json 를 따로 만들면 여기에 추가 가능
        </div>
      </div>

    </div>
  </div>

<script>
/* =========================
   Helpers
========================= */
async function fetchJSON(url) {
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
  return await r.json();
}

function toNum(x){
  const n = Number(String(x ?? "").replace(/,/g, ""));
  return Number.isFinite(n) ? n : 0;
}

function fmtPct(x, digits=2){
  if (x === null || x === undefined || Number.isNaN(Number(x))) return "—";
  return `${Number(x).toFixed(digits)}%`;
}

function fmtNum(x, digits=2){
  if (x === null || x === undefined || Number.isNaN(Number(x))) return "—";
  return Number(x).toFixed(digits);
}

function dateLabelToISO(label){
  // "2011/02" -> "2011-02"
  return String(label || "").trim().replace("/", "-");
}

function parseYearMonth(label){
  // accepts "YYYY/02" or "YYYY-02"
  const s = String(label || "").trim();
  const m = s.match(/^(\d{4})[\/\-](\d{2})$/);
  if (!m) return null;
  return { y: Number(m[1]), m: Number(m[2]) };
}

function lastNMonths(rows, n){
  if (!n) return rows;
  return rows.slice(Math.max(0, rows.length - n));
}

/* =========================
   FX (optional, for USD approximate display)
========================= */
async function getUSDJPYLive(){
  // open.er-api.com base USD
  // USDJPY = rates.JPY
  try{
    const j = await fetchJSON("https://open.er-api.com/v6/latest/USD");
    const jpy = j?.rates?.JPY;
    if (jpy && Number(jpy) > 0) return { usdjpy: Number(jpy), source: "open.er-api.com" };
  }catch(e){}
  return { usdjpy: null, source: "n/a" };
}

/* =========================
   Charts
========================= */
let chartXRP, chartJPBTC, chartKRWShare;

/* Basic line helper */
function makeLineChart(ctx, labels, data, yLabel){
  return new Chart(ctx, {
    type: "line",
    data: {
      labels,
      datasets: [{
        label: yLabel,
        data,
        tension: 0.2,
        pointRadius: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      plugins: { legend: { display: false } },
      scales: {
        x: { ticks: { maxTicksLimit: 10 } },
        y: { ticks: { maxTicksLimit: 6 } }
      }
    }
  });
}

/* =========================
   XRP (24H)
========================= */
async function renderXRP(){
  // KPI Latest
  try {
    const latest = await fetchJSON("out/global/k_xrp_share_24h_latest.json");
    document.getElementById("asof").textContent =
      `As of: ${latest.as_of || "—"} | FX: ${latest.fx_source || "—"}`;

    document.getElementById("kpi-xrp").textContent =
      fmtPct(latest.k_xrp_share_pct_24h, 4);
    document.getElementById("kpi-usdkrw").textContent =
      fmtNum(latest.usdkrw, 2);
    document.getElementById("kpi-xrp-errors").textContent =
      (latest.errors && latest.errors.length) ? String(latest.errors.length) : "0";

  } catch(e) {
    document.getElementById("kpi-xrp").textContent = "데이터 없음";
    document.getElementById("note-xrp-2").textContent = "* XRP latest JSON을 못 읽었습니다.";
  }

  // History chart (filter 0/invalid)
  try {
    const hist = await fetchJSON("out/global/k_xrp_share_24h_history.json");
    const cleaned = (hist || []).filter(x => {
      const v = Number(x.k_xrp_share_pct_24h);
      return Number.isFinite(v) && v > 0 && v < 100;
    });

    if (cleaned.length < 2) throw new Error("Not enough valid points");

    const labels = cleaned.map(x => (x.as_of || "").slice(0, 19).replace("T"," "));
    const series = cleaned.map(x => Number(x.k_xrp_share_pct_24h));

    const ctx = document.getElementById("chart-xrp").getContext("2d");
    if (chartXRP) chartXRP.destroy();
    chartXRP = makeLineChart(ctx, labels, series, "K-XRP Share (%)");

    const removed = (hist.length - cleaned.length);
    document.getElementById("note-xrp-2").textContent =
      removed > 0 ? `* 0/비정상 값 ${removed}개는 표시에서 제외` : "";

  } catch(e) {
    // fallback: latest 1pt
    try{
      const latest = await fetchJSON("out/global/k_xrp_share_24h_latest.json");
      const label = (latest.as_of || "latest").slice(0,19).replace("T"," ");
      const value = Number(latest.k_xrp_share_pct_24h || 0);
      const ctx = document.getElementById("chart-xrp").getContext("2d");
      if (chartXRP) chartXRP.destroy();
      chartXRP = makeLineChart(ctx, [label], [value], "K-XRP Share (%)");
      document.getElementById("note-xrp-2").textContent =
        "* 히스토리 유효값이 부족해서 latest 1포인트로 표시 중";
    }catch(_){}
  }
}

/* =========================
   JPBitcoin: Turnover(억엔) + Price + KRW Share
   - 막대: (통화별 BTC수량) * (월평균가 JPY/BTC) / 1e8  => 억엔
   - 라인: price (JPY/BTC)
========================= */
const JP_URL = "out/global/jpbitcoin_btc_monthly.json";

const state = {
  view: "month",     // "month" | "year"
  range: "all",      // "5y" | "10y" | "all"
  usdjpy: null,
  fxSource: null
};

function computeOkuYen(volumeBTC, priceJPY){
  const jpy = volumeBTC * priceJPY;
  return jpy / 1e8; // 억엔
}

function normalizeJPRows(rawRows){
  // ensure sorted by date asc
  const rows = (rawRows || [])
    .map(r => {
      const ym = parseYearMonth(r.date);
      return {
        y: ym?.y ?? null,
        m: ym?.m ?? null,
        date: r.date,
        label: dateLabelToISO(r.date),
        JPY: toNum(r.JPY),
        USD: toNum(r.USD),
        CNY: toNum(r.CNY),
        EUR: toNum(r.EUR),
        KRW: toNum(r.KRW),
        price: toNum(r.price)
      };
    })
    .filter(r => r.y && r.m)
    .sort((a,b) => (a.y*100+a.m) - (b.y*100+b.m));

  return rows;
}

function applyRange(rows){
  if (state.range === "5y") return lastNMonths(rows, 60);
  if (state.range === "10y") return lastNMonths(rows, 120);
  return rows;
}

function aggregateYearly(rows){
  // sum volumes in BTC, use simple avg price (mean) for line
  const map = new Map();
  for (const r of rows){
    const key = String(r.y);
    if (!map.has(key)){
      map.set(key, { year: key, JPY:0, USD:0, CNY:0, EUR:0, KRW:0, priceSum:0, priceN:0 });
    }
    const o = map.get(key);
    o.JPY += r.JPY;
    o.USD += r.USD;
    o.CNY += r.CNY;
    o.EUR += r.EUR;
    o.KRW += r.KRW;
    if (r.price > 0){
      o.priceSum += r.price;
      o.priceN += 1;
    }
  }
  const out = Array.from(map.values()).sort((a,b)=>Number(a.year)-Number(b.year));
  return out.map(o => ({
    label: o.year,
    JPY: o.JPY,
    USD: o.USD,
    CNY: o.CNY,
    EUR: o.EUR,
    KRW: o.KRW,
    price: (o.priceN>0 ? (o.priceSum/o.priceN) : 0)
  }));
}

function buildDatasetsFromRows(rows){
  // rows contain volumes in BTC and price in JPY/BTC, output: stacks in 억엔
  const labels = rows.map(r => r.label);
  const priceJPY = rows.map(r => r.price);

  const JPY_oku = rows.map((r,i) => computeOkuYen(r.JPY, priceJPY[i]));
  const USD_oku = rows.map((r,i) => computeOkuYen(r.USD, priceJPY[i]));
  const CNY_oku = rows.map((r,i) => computeOkuYen(r.CNY, priceJPY[i]));
  const EUR_oku = rows.map((r,i) => computeOkuYen(r.EUR, priceJPY[i]));
  const KRW_oku = rows.map((r,i) => computeOkuYen(r.KRW, priceJPY[i]));

  const total_oku = rows.map((r,i) => (JPY_oku[i]+USD_oku[i]+CNY_oku[i]+EUR_oku[i]+KRW_oku[i]));
  const krw_share_pct = rows.map((r,i) => total_oku[i] > 0 ? (KRW_oku[i]/total_oku[i])*100 : 0);

  return { labels, priceJPY, JPY_oku, USD_oku, CNY_oku, EUR_oku, KRW_oku, total_oku, krw_share_pct };
}

function updateButtons(){
  const setActive = (id, on) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.classList.toggle("active", !!on);
  };

  setActive("btn-view-month", state.view==="month");
  setActive("btn-view-year",  state.view==="year");

  setActive("btn-range-5y",  state.range==="5y");
  setActive("btn-range-10y", state.range==="10y");
  setActive("btn-range-all", state.range==="all");
}

function renderJPChartsFromData(normRows){
  const ranged = applyRange(normRows);
  const rowsForView = (state.view === "year") ? aggregateYearly(ranged) : ranged;

  const { labels, priceJPY, JPY_oku, USD_oku, CNY_oku, EUR_oku, KRW_oku, total_oku, krw_share_pct } =
    buildDatasetsFromRows(rowsForView);

  // USD approximate KPI (using current USDJPY, not monthly avg)
  if (state.usdjpy && state.usdjpy > 0 && total_oku.length){
    const lastTotalOku = total_oku[total_oku.length - 1];
    const lastTotalJPY = lastTotalOku * 1e8;
    const approxUSD = lastTotalJPY / state.usdjpy;
    document.getElementById("usd-approx-pill").textContent =
      `USD 환산(근사): $${Math.round(approxUSD).toLocaleString()} (최신기간)`;
  } else {
    document.getElementById("usd-approx-pill").textContent = `USD 환산(근사): —`;
  }

  // JP chart: stacked bars + price line
  const ctx = document.getElementById("chart-jpbtc").getContext("2d");
  if (chartJPBTC) chartJPBTC.destroy();

  chartJPBTC = new Chart(ctx, {
    data: {
      labels,
      datasets: [
        { type:"bar",  label:"JPY (억엔)", data: JPY_oku, stack:"amt", yAxisID:"yAmt" },
        { type:"bar",  label:"USD (억엔)", data: USD_oku, stack:"amt", yAxisID:"yAmt" },
        { type:"bar",  label:"CNY (억엔)", data: CNY_oku, stack:"amt", yAxisID:"yAmt" },
        { type:"bar",  label:"EUR (억엔)", data: EUR_oku, stack:"amt", yAxisID:"yAmt" },
        { type:"bar",  label:"KRW (억엔)", data: KRW_oku, stack:"amt", yAxisID:"yAmt" },

        { type:"line", label:"BTC Price (JPY)", data: priceJPY, yAxisID:"yPrice", tension:0.2, pointRadius:0 }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      interaction: { mode: "index", intersect: false },
      plugins: { legend: { display: true } },
      scales: {
        x: { stacked:true, ticks:{ maxTicksLimit: 10 } },
        yAmt: {
          stacked:true,
          position:"left",
          title:{ display:true, text: "Monthly Turnover (억엔)" },
          ticks:{ maxTicksLimit: 6 }
        },
        yPrice: {
          position:"right",
          grid:{ drawOnChartArea:false },
          title:{ display:true, text: "BTC Price (JPY/BTC)" },
          ticks:{ maxTicksLimit: 6 }
        }
      }
    }
  });

  // KRW share chart
  const ctx2 = document.getElementById("chart-krw-share").getContext("2d");
  if (chartKRWShare) chartKRWShare.destroy();
  chartKRWShare = makeLineChart(ctx2, labels, krw_share_pct, "KRW Share (%)");

  // note
  document.getElementById("note-jpbtc").textContent =
    `* 막대=거래액(월평균가 기준 엔환산, 억엔), 라인=평균 BTC가격(JPY/BTC). View=${state.view}, Range=${state.range}`;
}

async function renderJPBitcoin(){
  try{
    const raw = await fetchJSON(JP_URL);
    const norm = normalizeJPRows(raw);

    // FX
    const fx = await getUSDJPYLive();
    state.usdjpy = fx.usdjpy;
    state.fxSource = fx.source;

    document.getElementById("fx-pill").textContent =
      state.usdjpy ? `FX(USDJPY): ${fmtNum(state.usdjpy, 2)} (${state.fxSource})` : `FX(USDJPY): —`;

    renderJPChartsFromData(norm);

    // wire buttons once
    const wire = (id, fn) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener("click", fn);
    };

    wire("btn-view-month", () => { state.view="month"; updateButtons(); renderJPChartsFromData(norm); });
    wire("btn-view-year",  () => { state.view="year";  updateButtons(); renderJPChartsFromData(norm); });

    wire("btn-range-5y",  () => { state.range="5y";  updateButtons(); renderJPChartsFromData(norm); });
    wire("btn-range-10y", () => { state.range="10y"; updateButtons(); renderJPChartsFromData(norm); });
    wire("btn-range-all", () => { state.range="all"; updateButtons(); renderJPChartsFromData(norm); });

    updateButtons();

  }catch(e){
    document.getElementById("note-jpbtc").textContent =
      `* JPBitcoin JSON을 못 읽었습니다: ${e.message} (경로: ${JP_URL})`;
  }
}

/* =========================
   Boot
========================= */
(async function(){
  await renderXRP();
  await renderJPBitcoin();
})();
</script>

</body>
</html>

